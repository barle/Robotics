#include "Particle.h"

double RESOLUTION = 10;

Particle::Particle(int xPos, int yPos, double yawPos, Map* map, double belief)
{
	this->_belief = belief;
	this->_position = new Position(xPos, yPos, yawPos);
	this->_map = map;
}

double Particle::GetMovingProbability(double xDelta, double yDelta, double yawDelta)
{
	// Check if we didn't bypass the map's gridlines
	if (xDelta + this->_position->X() > MAP_MAX_X / RESOLUTION || yDelta + this->_position->Y() > MAP_MAX_Y / RESOLUTION)
	{
		return 0;
	}
	else
	{
		double distanceMoved = sqrt(pow(xDelta, 2) + pow(yDelta, 2));
		double probYaw = YAW_LOW_PROB;
		double probMoving = MOVING_LOW_PROB;

		// Make sure we didn't rotate to much
		if (yawDelta < DTOR(NORMAL_YAW_DEGREES) && yawDelta > (-1) * DTOR(NORMAL_YAW_DEGREES))
		{
			probYaw = YAW_HIGH_PROB;
		}
		else if (yawDelta < DTOR(MAX_YAW_DEGREES) && yawDelta > (-1) * DTOR(MAX_YAW_DEGREES))
		{
			probYaw = YAW_OK_PROB;
		}

		// Make sure we moved by a logical distance
		if (distanceMoved < NORMAL_MOVING && distanceMoved > (-1) * NORMAL_MOVING)
		{
			probMoving = MOVING_HIGH_PROB;
		}
		else if (distanceMoved < MAX_MOVING && distanceMoved > (-1) * MAX_MOVING)
		{
			probMoving = MOVING_OK_PROB;
		}

		return probYaw * probMoving;
	}
	return 0;
}

double Particle::UpdateMapAndCheckProbability(double* laserScans)
{
	double hits = 0;
	double misses = 0;

	// Go over the laser's array by a constant jump range

	for (int index = 0; index < LASER_COUNT; index += LASER_JUMP_INDEX)
	{
		if (laserScans[index] < LASER_MAX_RANGE)
		{
			// Go over the relevant cells in between the occupied cell and the free cells
			for(int j = 0; j < (((laserScans[index] / LASER_MAX_RANGE) * MAP_MAX_CELLS_LASER) / RESOLUTION); j++)
			{
				int XFreePos = this->_position->X() + (sin(DTOR(AngleOfIndex(index)) + this->_position->Yaw()) * j);
				int YFreePos = this->_position->Y() + (cos(DTOR(AngleOfIndex(index)) + this->_position->Yaw()) * j);

				// Make sure we are in safe bounds
				if (XFreePos >= 0 && XFreePos < _map->GetWidth() / RESOLUTION && YFreePos >= 0 && YFreePos < _map->GetHeight() / RESOLUTION)
				{
					if (this->_map->isOccupied(YFreePos, XFreePos))
					{
						misses++;
					}
					else
					{
						hits++;
					}
				}
			}

			// Calculate the occupied position
			int XOccupiedPos = this->_position->X() + (sin(DTOR(AngleOfIndex(index)) + this->_position->Yaw()) * (((laserScans[index] / LASER_MAX_RANGE) * MAP_MAX_CELLS_LASER) / RESOLUTION));
			int YOccupiedPos = this->_position->Y() + (cos(DTOR(AngleOfIndex(index)) + this->_position->Yaw()) * (((laserScans[index] / LASER_MAX_RANGE) * MAP_MAX_CELLS_LASER) / RESOLUTION));

			// Make sure we are in safe array bounds
			if (XOccupiedPos >= 0 && XOccupiedPos < MAP_MAX_X / RESOLUTION && YOccupiedPos >= 0 && YOccupiedPos < MAP_MAX_Y / RESOLUTION)
			{
				if (this->_map->GetOccupancyStatus(YOccupiedPos, XOccupiedPos) == MAP_OCCUPIED)
				{
					hits++;
				}
				else if (this->_map->GetOccupancyStatus(YOccupiedPos, XOccupiedPos) == MAP_FREE)
				{
					misses++;
				}

				// Update the cell
				this->_map->UpdateCell(YOccupiedPos, XOccupiedPos, MAP_OCCUPIED);
			}
		}
		else
		{
			// Go over all the cells in this angle and make sure we mark them as free
			for(int j = 0; j < (((laserScans[index] / LASER_MAX_RANGE) * MAP_MAX_CELLS_LASER) / RESOLUTION); j += 1)
			{
				int XFreePos = this->_xVal + (sin(DTOR(AngleOfIndex(index)) + this->_yawVal) * j);
				int YFreePos = this->_yVal + (cos(DTOR(AngleOfIndex(index)) + this->_yawVal) * j);

				// Make sure we are in safe array bounds
				if (XFreePos >= 0 && XFreePos < MAP_MAX_X / RESOLUTION && YFreePos >= 0 && YFreePos < MAP_MAX_Y / RESOLUTION)
				{
					if (this->_map->GetOccupancyStatus(YFreePos, XFreePos) == MAP_FREE)
					{
						hits++;
					}
					else if (this->_map->GetOccupancyStatus(YFreePos, XFreePos) == MAP_OCCUPIED)
					{
						misses++;
					}

					this->_map->UpdateCell(YFreePos, XFreePos, MAP_FREE);
				}
			}
		}

	}

	// Calculate hits/total value
	if (hits != 0 || misses != 0)
	{
		return hits / (hits + misses);
	}
	return 1;
}

double Particle::AngleOfIndex(int index)
{
	// Calculate angle by laser index
	return index * MEASURING_AREA - 360 + ANGULAR_RESOLUTION;
}

void Particle::Update(double xDelta, double yDelta, double yawDelta, double* laserScans)
{
	/*
	this->_xVal += xDelta / RESOLUTION;
	this->_yVal += yDelta / RESOLUTION;
	this->_yawVal += yawDelta;

	// Calculate belief by moving probability
	this->_belief = this->_belief * Particle::GetMovingProbability(xDelta, yDelta, yawDelta);

	if (this->_belief != 0)
	{
		// Calculate belief by map relevance probability
		this->_belief = this->_belief * Particle::UpdateMapAndCheckProbability(laserScans);
	}

}

Position* Particle::GetPosition()
{
	return this->_position;
}

double Particle::GetBelief()
{
	return this->_belief;
}

void Particle::Print()
{
	// Print robot position
	cout << "Robot position: " << this->_position->X() << ", " << this->_position->Y() << ", yaw: " << this->_position->Yaw() << endl;
}

Particle::~Particle() {

}
